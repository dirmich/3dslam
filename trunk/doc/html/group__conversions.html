<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>3DSlam: Parsing XML files/strings to an XMLNode structure and Rendering XMLNode&#39;s to files/string.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Parsing XML files/strings to an XMLNode structure and Rendering XMLNode's to files/string.</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gcb95f4f00e4cf3756aac0e3a53765248">XMLNode::parseString</a> (XMLCSTR lpXMLString, XMLCSTR tag=NULL, <a class="el" href="struct_x_m_l_results.html">XMLResults</a> *pResults=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the string.  <a href="#gcb95f4f00e4cf3756aac0e3a53765248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#g5e5968e052d58350918cd91e3535624b">XMLNode::parseFile</a> (XMLCSTR filename, XMLCSTR tag=NULL, <a class="el" href="struct_x_m_l_results.html">XMLResults</a> *pResults=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file.  <a href="#g5e5968e052d58350918cd91e3535624b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="struct_x_m_l_node.html">XMLNode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gcc044148e2b9b8264a320b7b6e398158">XMLNode::openFileHelper</a> (XMLCSTR filename, XMLCSTR tag=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. A very crude error checking is made. An attempt to guess the Char Encoding used in the file is made.  <a href="#gcc044148e2b9b8264a320b7b6e398158"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static XMLCSTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#g4496629c7a268db5435946c7bdd4eb28">XMLNode::getError</a> (<a class="el" href="xml_parser_8h.html#c39bd07b1461aaa70afffe2d7162b4f5">XMLError</a> error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this gives you a user-friendly explanation of the parsing error  <a href="#g4496629c7a268db5435946c7bdd4eb28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">XMLSTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gc8710ba5e7ff6e62a222445501ef9972">XMLNode::createXMLString</a> (int nFormat=1, int *pnSize=NULL) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="struct_x_m_l.html">XML</a> string starting from the current <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a>.  <a href="#gc8710ba5e7ff6e62a222445501ef9972"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="xml_parser_8h.html#c39bd07b1461aaa70afffe2d7162b4f5">XMLError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gb8d92d057c0072cc195b1935b2f53d80">XMLNode::writeToFile</a> (XMLCSTR filename, const char *encoding=NULL, char nFormat=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save the content of an xmlNode inside a file.  <a href="#gb8d92d057c0072cc195b1935b2f53d80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#g2be69aa6c6baec814f54f1bc23e33b4b">XMLNode::setGlobalOptions</a> (XMLCharEncoding <a class="el" href="xml_parser_8cpp.html#ab8c180274ed444bbc56a3f413fe106c">characterEncoding</a>=XMLNode::encoding_UTF8, char <a class="el" href="xml_parser_8cpp.html#dec6e4712d4545b0fcc11000dc0dc0ca">guessWideCharChars</a>=1, char <a class="el" href="xml_parser_8cpp.html#5873e61a244487ba540cb71b39b630f7">dropWhiteSpace</a>=1, char <a class="el" href="xml_parser_8cpp.html#b794929f064bd5c8afe7eb4c5ecd3e62">removeCommentsInMiddleOfText</a>=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the global options for the conversions.  <a href="#g2be69aa6c6baec814f54f1bc23e33b4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static XMLCharEncoding&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gc7af7e3bab8d21722dd4f191a4aa7c1d">XMLNode::guessCharEncoding</a> (void *buffer, int bufLen, char useXMLEncodingAttribute=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Guess the character encoding of the string (ascii, utf8 or shift-JIS).  <a href="#gc7af7e3bab8d21722dd4f191a4aa7c1d"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gc8710ba5e7ff6e62a222445501ef9972"></a><!-- doxytag: member="XMLNode::createXMLString" ref="gc8710ba5e7ff6e62a222445501ef9972" args="(int nFormat=1, int *pnSize=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLSTR XMLNode::createXMLString           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFormat</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnSize</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an <a class="el" href="struct_x_m_l.html">XML</a> string starting from the current <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a>. 
<p>
If nFormat==0, no formatting is required otherwise this returns an user friendly <a class="el" href="struct_x_m_l.html">XML</a> string from a given element with appropriate white spaces and carriage returns. if pnSize is given it returns the size in character of the string. 
<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l02035">2035</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8cpp-source.html#l01771">XMLNode::CreateXMLStringR()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">dropWhiteSpace</a>, <a class="el" href="xml_parser_8h-source.html#l00080">XMLCHAR</a>, and <a class="el" href="xml_parser_8h-source.html#l00079">XMLSTR</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l00527">XMLNode::writeToFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4496629c7a268db5435946c7bdd4eb28"></a><!-- doxytag: member="XMLNode::getError" ref="g4496629c7a268db5435946c7bdd4eb28" args="(XMLError error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLCSTR XMLNode::getError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xml_parser_8h.html#c39bd07b1461aaa70afffe2d7162b4f5">XMLError</a>&nbsp;</td>
          <td class="paramname"> <em>error</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
this gives you a user-friendly explanation of the parsing error 
<p>

<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l00117">117</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8h-source.html#l00077">_CXML</a>, <a class="el" href="xml_parser_8h-source.html#l00111">eXMLErrorBase64DataSizeIsNotMultipleOf4</a>, <a class="el" href="xml_parser_8h-source.html#l00114">eXMLErrorBase64DecodeBufferTooSmall</a>, <a class="el" href="xml_parser_8h-source.html#l00112">eXMLErrorBase64DecodeIllegalCharacter</a>, <a class="el" href="xml_parser_8h-source.html#l00113">eXMLErrorBase64DecodeTruncatedData</a>, <a class="el" href="xml_parser_8h-source.html#l00108">eXMLErrorCannotOpenWriteFile</a>, <a class="el" href="xml_parser_8h-source.html#l00109">eXMLErrorCannotWriteFile</a>, <a class="el" href="xml_parser_8h-source.html#l00106">eXMLErrorCharacterCodeAbove255</a>, <a class="el" href="xml_parser_8h-source.html#l00107">eXMLErrorCharConversionError</a>, <a class="el" href="xml_parser_8h-source.html#l00096">eXMLErrorEmpty</a>, <a class="el" href="xml_parser_8h-source.html#l00103">eXMLErrorFileNotFound</a>, <a class="el" href="xml_parser_8h-source.html#l00104">eXMLErrorFirstTagNotFound</a>, <a class="el" href="xml_parser_8h-source.html#l00094">eXMLErrorMissingEndTag</a>, <a class="el" href="xml_parser_8h-source.html#l00098">eXMLErrorMissingEndTagName</a>, <a class="el" href="xml_parser_8h-source.html#l00097">eXMLErrorMissingTagName</a>, <a class="el" href="xml_parser_8h-source.html#l00102">eXMLErrorNoElements</a>, <a class="el" href="xml_parser_8h-source.html#l00093">eXMLErrorNone</a>, <a class="el" href="xml_parser_8h-source.html#l00095">eXMLErrorNoXMLTagFound</a>, <a class="el" href="xml_parser_8h-source.html#l00101">eXMLErrorUnexpectedToken</a>, <a class="el" href="xml_parser_8h-source.html#l00105">eXMLErrorUnknownCharacterEntity</a>, <a class="el" href="xml_parser_8h-source.html#l00100">eXMLErrorUnmatchedEndClearTag</a>, and <a class="el" href="xml_parser_8h-source.html#l00099">eXMLErrorUnmatchedEndTag</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l00364">XMLNode::openFileHelper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc7af7e3bab8d21722dd4f191a4aa7c1d"></a><!-- doxytag: member="XMLNode::guessCharEncoding" ref="gc7af7e3bab8d21722dd4f191a4aa7c1d" args="(void *buffer, int bufLen, char useXMLEncodingAttribute=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html#81bcd09f9c752b65633c1ca28ea025f2">XMLNode::XMLCharEncoding</a> XMLNode::guessCharEncoding           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>useXMLEncodingAttribute</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Guess the character encoding of the string (ascii, utf8 or shift-JIS). 
<p>
The "guessCharEncoding" function try to guess the character encoding. You most-probably will never have to use this function. It then returns the appropriate value of the global parameter "characterEncoding" described in the <a class="el" href="group__conversions.html#g2be69aa6c6baec814f54f1bc23e33b4b" title="Sets the global options for the conversions.">XMLNode::setGlobalOptions</a>. The guess is based on the content of a buffer of length "bufLen" bytes that contains the first bytes (minimum 25 bytes; 200 bytes is a good value) of the file to be parsed. The <a class="el" href="group__conversions.html#gcc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A...">XMLNode::openFileHelper</a> function is using this function to automatically compute the value of the "characterEncoding" global parameter. There are several heuristics used to do the guess. One of the heuristic is based on the "encoding" attribute. The original <a class="el" href="struct_x_m_l.html">XML</a> specifications forbids to use this attribute to do the guess but you can still use it if you set "useXMLEncodingAttribute" to 1 (this is the default behavior and the behavior of most parsers). If an inconsistency in the encoding is detected, then the return value is "0". 
<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l02579">2579</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8h-source.html#l00404">XMLNode::encoding_ascii</a>, <a class="el" href="xml_parser_8h-source.html#l00405">XMLNode::encoding_ShiftJIS</a>, <a class="el" href="xml_parser_8h-source.html#l00403">XMLNode::encoding_UTF8</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">guessWideCharChars</a>, <a class="el" href="xml_parser_8cpp-source.html#l00077">mmin()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00160">myIsTextWideChar()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00766">XML_isSPACECHAR</a>, and <a class="el" href="xml_parser_8cpp-source.html#l00312">xstrnicmp()</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l00364">XMLNode::openFileHelper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcc044148e2b9b8264a320b7b6e398158"></a><!-- doxytag: member="XMLNode::openFileHelper" ref="gcc044148e2b9b8264a320b7b6e398158" args="(XMLCSTR filename, XMLCSTR tag=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::openFileHelper           </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. A very crude error checking is made. An attempt to guess the Char Encoding used in the file is made. 
<p>
The "openFileHelper" function reports to the screen all the warnings and errors that occurred during parsing of the <a class="el" href="struct_x_m_l.html">XML</a> file. This function also tries to guess char Encoding (UTF-8, ASCII or SHIT-JIS) based on the first 200 bytes of the file. Since each application has its own way to report and deal with errors, you should rather use the "parseFile" function to parse <a class="el" href="struct_x_m_l.html">XML</a> files and program yourself thereafter an "error reporting" tailored for your needs (instead of using the very crude "error reporting" mechanism included inside the "openFileHelper" function).<p>
If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "openFileHelper" method will:<ul>
<li>display an error message on the console (or inside a messageBox for windows).</li><li>stop execution (exit). I strongly suggest that you write your own "openFileHelper" method tailored to your needs. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>the path of the <a class="el" href="struct_x_m_l.html">XML</a> file to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l00364">364</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8h-source.html#l00077">_CXML</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">dropWhiteSpace</a>, <a class="el" href="xml_parser_8h-source.html#l00131">XMLResults::error</a>, <a class="el" href="xml_parser_8h-source.html#l00104">eXMLErrorFirstTagNotFound</a>, <a class="el" href="xml_parser_8h-source.html#l00093">eXMLErrorNone</a>, <a class="el" href="xml_parser_8cpp-source.html#l00117">XMLNode::getError()</a>, <a class="el" href="xml_parser_8cpp-source.html#l02579">XMLNode::guessCharEncoding()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">guessWideCharChars</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nColumn</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nLine</a>, <a class="el" href="xml_parser_8cpp-source.html#l01714">XMLNode::parseFile()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">removeCommentsInMiddleOfText</a>, <a class="el" href="xml_parser_8cpp-source.html#l02561">XMLNode::setGlobalOptions()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00310">xfopen()</a>, and <a class="el" href="xml_parser_8h-source.html#l00078">XMLCSTR</a>.</p>

<p>Referenced by <a class="el" href="test2_8cpp-source.html#l00385">main()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5e5968e052d58350918cd91e3535624b"></a><!-- doxytag: member="XMLNode::parseFile" ref="g5e5968e052d58350918cd91e3535624b" args="(XMLCSTR filename, XMLCSTR tag=NULL, XMLResults *pResults=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::parseFile           </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_results.html">XMLResults</a> *&nbsp;</td>
          <td class="paramname"> <em>pResults</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the file. 
<p>
The "parseFile" function parse an <a class="el" href="struct_x_m_l.html">XML</a> file and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. The "opposite" of this function is the function "writeToFile" that re-creates an <a class="el" href="struct_x_m_l.html">XML</a> file from an <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "parseFile" method will initialize the "pResults" variable with some information that can be used to trace the error. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>the path to the <a class="el" href="struct_x_m_l.html">XML</a> file to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pResults</em>&nbsp;</td><td>a pointer to a <a class="el" href="struct_x_m_l_results.html" title="Structure used to obtain error details if the parse fails.">XMLResults</a> variable that will contain some information that can be used to trace the <a class="el" href="struct_x_m_l.html">XML</a> parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l01714">1714</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8h-source.html#l00077">_CXML</a>, <a class="el" href="xml_parser_8h-source.html#l00275">XMLNode::emptyXMLNode</a>, <a class="el" href="xml_parser_8h-source.html#l00404">XMLNode::encoding_ascii</a>, <a class="el" href="xml_parser_8h-source.html#l00403">XMLNode::encoding_UTF8</a>, <a class="el" href="xml_parser_8h-source.html#l00131">XMLResults::error</a>, <a class="el" href="xml_parser_8h-source.html#l00107">eXMLErrorCharConversionError</a>, <a class="el" href="xml_parser_8h-source.html#l00096">eXMLErrorEmpty</a>, <a class="el" href="xml_parser_8h-source.html#l00103">eXMLErrorFileNotFound</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">guessWideCharChars</a>, <a class="el" href="xml_parser_8cpp-source.html#l00160">myIsTextWideChar()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00263">myWideCharToMultiByte()</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nColumn</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nLine</a>, <a class="el" href="xml_parser_8cpp-source.html#l01643">XMLNode::parseString()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00310">xfopen()</a>, and <a class="el" href="xml_parser_8h-source.html#l00079">XMLSTR</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l00364">XMLNode::openFileHelper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcb95f4f00e4cf3756aac0e3a53765248"></a><!-- doxytag: member="XMLNode::parseString" ref="gcb95f4f00e4cf3756aac0e3a53765248" args="(XMLCSTR lpXMLString, XMLCSTR tag=NULL, XMLResults *pResults=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_l_node.html">XMLNode</a> XMLNode::parseString           </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>lpXMLString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_results.html">XMLResults</a> *&nbsp;</td>
          <td class="paramname"> <em>pResults</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree representing the string. 
<p>
The "parseString" function parse an <a class="el" href="struct_x_m_l.html">XML</a> string and return the root of a <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. The "opposite" of this function is the function "createXMLString" that re-creates an <a class="el" href="struct_x_m_l.html">XML</a> string from an <a class="el" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> tree. If the <a class="el" href="struct_x_m_l.html">XML</a> document is corrupted, the "parseString" method will initialize the "pResults" variable with some information that can be used to trace the error. If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lpXMLString</em>&nbsp;</td><td>the <a class="el" href="struct_x_m_l.html">XML</a> string to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>the name of the first tag inside the <a class="el" href="struct_x_m_l.html">XML</a> file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (&lt;? ... ?&gt;). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pResults</em>&nbsp;</td><td>a pointer to a <a class="el" href="struct_x_m_l_results.html" title="Structure used to obtain error details if the parse fails.">XMLResults</a> variable that will contain some information that can be used to trace the <a class="el" href="struct_x_m_l.html">XML</a> parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l01643">1643</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8cpp-source.html#l01620">CountLinesAndColumns()</a>, <a class="el" href="xml_parser_8h-source.html#l00275">XMLNode::emptyXMLNode</a>, <a class="el" href="xml_parser_8cpp-source.html#l00497">XML::error</a>, <a class="el" href="xml_parser_8h-source.html#l00131">XMLResults::error</a>, <a class="el" href="xml_parser_8h-source.html#l00104">eXMLErrorFirstTagNotFound</a>, <a class="el" href="xml_parser_8h-source.html#l00094">eXMLErrorMissingEndTag</a>, <a class="el" href="xml_parser_8h-source.html#l00102">eXMLErrorNoElements</a>, <a class="el" href="xml_parser_8h-source.html#l00093">eXMLErrorNone</a>, <a class="el" href="xml_parser_8h-source.html#l00095">eXMLErrorNoXMLTagFound</a>, <a class="el" href="xml_parser_8h-source.html#l00083">FALSE</a>, <a class="el" href="xml_parser_8cpp-source.html#l02520">XMLNode::getChildNode()</a>, <a class="el" href="xml_parser_8cpp-source.html#l02509">XMLNode::getName()</a>, <a class="el" href="xml_parser_8cpp-source.html#l02522">XMLNode::isDeclaration()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00494">XML::lpXML</a>, <a class="el" href="xml_parser_8cpp-source.html#l02346">XMLNode::nChildNode()</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nColumn</a>, <a class="el" href="xml_parser_8cpp-source.html#l02514">XMLNode::nElement()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00496">XML::nIndex</a>, <a class="el" href="xml_parser_8cpp-source.html#l00496">XML::nIndexMissigEndTag</a>, <a class="el" href="xml_parser_8h-source.html#l00132">XMLResults::nLine</a>, <a class="el" href="xml_parser_8cpp-source.html#l01209">XMLNode::ParseXMLElement()</a>, <a class="el" href="xml_parser_8h-source.html#l00086">TRUE</a>, <a class="el" href="xml_parser_8h-source.html#l00078">XMLCSTR</a>, <a class="el" href="xml_parser_8cpp-source.html#l00314">xstricmp()</a>, and <a class="el" href="xml_parser_8cpp-source.html#l00311">xstrlen()</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l01714">XMLNode::parseFile()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2be69aa6c6baec814f54f1bc23e33b4b"></a><!-- doxytag: member="XMLNode::setGlobalOptions" ref="g2be69aa6c6baec814f54f1bc23e33b4b" args="(XMLCharEncoding characterEncoding=XMLNode::encoding_UTF8, char guessWideCharChars=1, char dropWhiteSpace=1, char removeCommentsInMiddleOfText=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char XMLNode::setGlobalOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_l_node.html#81bcd09f9c752b65633c1ca28ea025f2">XMLCharEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>characterEncoding</em> = <code>XMLNode::encoding_UTF8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>guessWideCharChars</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>dropWhiteSpace</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>removeCommentsInMiddleOfText</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global options for the conversions. 
<p>
The "setGlobalOptions" function allows you to change four global parameters that affect string &amp; file parsing. First of all, you most-probably will never have to change these 3 global parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>guessWideCharChars</em>&nbsp;</td><td>If "guessWideCharChars"=1 and if this library is compiled in WideChar mode, then the <a class="el" href="group__conversions.html#g5e5968e052d58350918cd91e3535624b" title="Parse an XML file and return the root of a XMLNode tree representing the file.">XMLNode::parseFile</a> and <a class="el" href="group__conversions.html#gcc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A...">XMLNode::openFileHelper</a> functions will test if the file contains ASCII characters. If this is the case, then the file will be loaded and converted in memory to WideChar before being parsed. If 0, no conversion will be performed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>guessWideCharChars</em>&nbsp;</td><td>If "guessWideCharChars"=1 and if this library is compiled in ASCII/UTF8/char* mode, then the <a class="el" href="group__conversions.html#g5e5968e052d58350918cd91e3535624b" title="Parse an XML file and return the root of a XMLNode tree representing the file.">XMLNode::parseFile</a> and <a class="el" href="group__conversions.html#gcc044148e2b9b8264a320b7b6e398158" title="Parse an XML file and return the root of a XMLNode tree representing the file. A...">XMLNode::openFileHelper</a> functions will test if the file contains WideChar characters. If this is the case, then the file will be loaded and converted in memory to ASCII/UTF8/char* before being parsed. If 0, no conversion will be performed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>characterEncoding</em>&nbsp;</td><td>This parameter is only meaningful when compiling in char* mode (multibyte character mode). In wchar_t* (wide char mode), this parameter is ignored. This parameter should be one of the three currently recognized encodings: <a class="el" href="struct_x_m_l_node.html#81bcd09f9c752b65633c1ca28ea025f28b5640ec346f94f284092c24ac3da153">XMLNode::encoding_UTF8</a>, <a class="el" href="struct_x_m_l_node.html#81bcd09f9c752b65633c1ca28ea025f231896734530146e0ac5cfb07e4e3dd44">XMLNode::encoding_ascii</a>, <a class="el" href="struct_x_m_l_node.html#81bcd09f9c752b65633c1ca28ea025f2e6d0b81fd1efd035a8551319399b5d59">XMLNode::encoding_ShiftJIS</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dropWhiteSpace</em>&nbsp;</td><td>In most situations, text fields containing only white spaces (and carriage returns) are useless. Even more, these "empty" text fields are annoying because they increase the complexity of the user's code for parsing. So, 99% of the time, it's better to drop the "empty" text fields. However The <a class="el" href="struct_x_m_l.html">XML</a> specification indicates that no white spaces should be lost when parsing the file. So to be perfectly XML-compliant, you should set dropWhiteSpace=0. A note of caution: if you set "dropWhiteSpace=0", the parser will be slower and your code will be more complex.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>removeCommentsInMiddleOfText</em>&nbsp;</td><td>To explain this parameter, let's consider this code: <div class="fragment"><pre class="fragment">        <a class="code" href="struct_x_m_l_node.html" title="Main Class representing a XML node.">XMLNode</a> x=<a class="code" href="group__conversions.html#gcb95f4f00e4cf3756aac0e3a53765248" title="Parse an XML string and return the root of a XMLNode tree representing the string...">XMLNode::parseString</a>(<span class="stringliteral">"&lt;a&gt;foo&lt;!-- hello --&gt;bar&lt;!DOCTYPE world &gt;chu&lt;/a&gt;"</span>,<span class="stringliteral">"a"</span>);
</pre></div> If removeCommentsInMiddleOfText=0, then we will have: <div class="fragment"><pre class="fragment">        x.<a class="code" href="group__navigate.html#geb607292b18d4615b7c169c7c08c0a8b" title="return ith text field">getText</a>(0) -&gt; <span class="stringliteral">"foo"</span>
        x.<a class="code" href="group__navigate.html#geb607292b18d4615b7c169c7c08c0a8b" title="return ith text field">getText</a>(1) -&gt; <span class="stringliteral">"bar"</span>
        x.<a class="code" href="group__navigate.html#geb607292b18d4615b7c169c7c08c0a8b" title="return ith text field">getText</a>(2) -&gt; <span class="stringliteral">"chu"</span>
        x.<a class="code" href="group__navigate.html#gb99fbcb5534ab2194889c4802e290354" title="return ith clear field (comments)">getClear</a>(0) --&gt; <span class="stringliteral">"&lt;!-- hello --&gt;"</span>
        x.<a class="code" href="group__navigate.html#gb99fbcb5534ab2194889c4802e290354" title="return ith clear field (comments)">getClear</a>(1) --&gt; <span class="stringliteral">"&lt;!DOCTYPE world &gt;"</span>
</pre></div> If removeCommentsInMiddleOfText=1, then we will have: <div class="fragment"><pre class="fragment">        x.<a class="code" href="group__navigate.html#geb607292b18d4615b7c169c7c08c0a8b" title="return ith text field">getText</a>(0) -&gt; <span class="stringliteral">"foobar"</span>
        x.<a class="code" href="group__navigate.html#geb607292b18d4615b7c169c7c08c0a8b" title="return ith text field">getText</a>(1) -&gt; <span class="stringliteral">"chu"</span>
        x.<a class="code" href="group__navigate.html#gb99fbcb5534ab2194889c4802e290354" title="return ith clear field (comments)">getClear</a>(0) --&gt; <span class="stringliteral">"&lt;!DOCTYPE world &gt;"</span>
</pre></div></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>"0" when there are no errors. If you try to set an unrecognized encoding then the return value will be "1" to signal an error.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Sometime, it's useful to set "guessWideCharChars=0" to disable any conversion because the test to detect the file-type (ASCII/UTF8/char* or WideChar) may fail (rarely). </dd></dl>

<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l02561">2561</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8cpp-source.html#l00074">characterEncoding</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">dropWhiteSpace</a>, <a class="el" href="xml_parser_8h-source.html#l00404">XMLNode::encoding_ascii</a>, <a class="el" href="xml_parser_8h-source.html#l00405">XMLNode::encoding_ShiftJIS</a>, <a class="el" href="xml_parser_8h-source.html#l00403">XMLNode::encoding_UTF8</a>, <a class="el" href="xml_parser_8cpp-source.html#l00075">guessWideCharChars</a>, and <a class="el" href="xml_parser_8cpp-source.html#l00075">removeCommentsInMiddleOfText</a>.</p>

<p>Referenced by <a class="el" href="xml_parser_8cpp-source.html#l00364">XMLNode::openFileHelper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb8d92d057c0072cc195b1935b2f53d80"></a><!-- doxytag: member="XMLNode::writeToFile" ref="gb8d92d057c0072cc195b1935b2f53d80" args="(XMLCSTR filename, const char *encoding=NULL, char nFormat=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xml_parser_8h.html#c39bd07b1461aaa70afffe2d7162b4f5">XMLError</a> XMLNode::writeToFile           </td>
          <td>(</td>
          <td class="paramtype">XMLCSTR&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>nFormat</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save the content of an xmlNode inside a file. 
<p>
If nFormat==0, no formatting is required otherwise this returns an user friendly <a class="el" href="struct_x_m_l.html">XML</a> string from a given element with appropriate white spaces and carriage returns. If the global parameter "characterEncoding==encoding_UTF8", then the "encoding" parameter is ignored and always set to "utf-8". If the global parameter "characterEncoding==encoding_ShiftJIS", then the "encoding" parameter is ignored and always set to "SHIFT-JIS". If "_XMLWIDECHAR=1", then the "encoding" parameter is ignored and always set to "utf-16". If no "encoding" parameter is given the "ISO-8859-1" encoding is used. 
<p>Definition at line <a class="el" href="xml_parser_8cpp-source.html#l00527">527</a> of file <a class="el" href="xml_parser_8cpp-source.html">xmlParser.cpp</a>.</p>

<p>References <a class="el" href="xml_parser_8h-source.html#l00077">_CXML</a>, <a class="el" href="xml_parser_8cpp-source.html#l00074">characterEncoding</a>, <a class="el" href="xml_parser_8cpp-source.html#l02035">XMLNode::createXMLString()</a>, <a class="el" href="xml_parser_8h-source.html#l00405">XMLNode::encoding_ShiftJIS</a>, <a class="el" href="xml_parser_8h-source.html#l00403">XMLNode::encoding_UTF8</a>, <a class="el" href="xml_parser_8h-source.html#l00108">eXMLErrorCannotOpenWriteFile</a>, <a class="el" href="xml_parser_8h-source.html#l00109">eXMLErrorCannotWriteFile</a>, <a class="el" href="xml_parser_8h-source.html#l00093">eXMLErrorNone</a>, <a class="el" href="xml_parser_8cpp-source.html#l02520">XMLNode::getChildNode()</a>, <a class="el" href="xml_parser_8cpp-source.html#l02522">XMLNode::isDeclaration()</a>, <a class="el" href="xml_parser_8cpp-source.html#l00310">xfopen()</a>, <a class="el" href="xml_parser_8h-source.html#l00080">XMLCHAR</a>, and <a class="el" href="xml_parser_8h-source.html#l00079">XMLSTR</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 27 22:08:06 2008 for 3DSlam by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
